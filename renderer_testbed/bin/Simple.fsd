#version 450

in vec4 _Colour;
in vec2 _TexCoord;
in vec3 _Normal;
in mat3 _TBN;
in vec3 _Position;
in vec3 _Tangent;
in vec3 _Bitangent;
//in vec3 N; // normalised surface normal

uniform sampler2D texture_diffuse;  // diffuse
uniform sampler2D texture_specular; // diffuse
uniform sampler2D texture_normal;   // normal map
uniform vec3 L = vec3(-1, -1, 0);  // normalised light direction from the light

// environment ambient light and diffuse light
uniform vec3 iA;
uniform vec3 iD;
uniform vec3 camera_pos;
uniform float specular_power = 0.5;
uniform mat4 model_matrix;

out vec4 FragColour;

void main() {
	vec3 tex_diffuse = texture(texture_diffuse, _TexCoord).xyz; // surface diffuse
	// vec3 tex_normal = texture(texture_normal, _TexCoord) * 2 - 1;
	vec3 tex_normal = texture(texture_normal, _TexCoord).xyz;

	vec3 kD = vec3(1, 1, 1); // material colour
	vec3 kA = kD; // surface ambient
	vec3 kS = normalize(kD); // material specular


	// lambert term with L reversed to face the light
	vec3 T = normalize(_Tangent);
	vec3 B = normalize(_Bitangent);
	vec3 N = normalize(_Normal);
	mat3 TBN = mat3(T, B, N);

	N = TBN * (tex_normal * 2 - 1);
	N = (model_matrix * vec4(N, 0)).xyz;

	// vec3 N = (TBN * n).xyz;
	float lambert_term = max( 0.0, dot(N, -L));

	// calculate view vector and reflection vector
	vec3 V = normalize(camera_pos - _Position);
	vec3 R = reflect( L, N );

	// calculate specular term
	float specular_term = pow(max(0, dot( R, V )), specular_power);

	// calculate each light properly
	vec3 ambient  = kA * iA * tex_diffuse;                // ambient light
	vec3 diffuse  = kD * iD * tex_diffuse * lambert_term; // diffuse light for one light
	vec3 specular = iA * kS * tex_diffuse * specular_term;

	FragColour = vec4(tex_diffuse, 1);
	// FragColour = vec4(N, 1);
}