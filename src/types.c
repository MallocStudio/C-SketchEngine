#include "types.h"
#include "assert.h"
#include <memory.h>
#include "core.h"

///
SDL_Color rgba_to_sdl_color(const RGBA *rgba) {
    SDL_Color color;
    color.r = rgba->r * 255;
    color.g = rgba->g * 255;
    color.b = rgba->b * 255;
    color.a = rgba->a * 255;
    return color;
}

/// text should not be null
/// stores a pointer to the renderer and font for future use
/// allocates memory based on data
/// copies RGBA color to text->color
void init_text(Text *text, SDL_Renderer *renderer, const char *data, TTF_Font *font, RGBA color) {
    assert(text != NULL && "init_text: text was null");
    text->font = font;
    text->dynamic = false;
    text->buffer = (char*) malloc (sizeof(char) * (strlen(data) + 1));
    text->buffer = strcpy(text->buffer, data);
    text->color = color;
    text->renderer = renderer;
    // text->surface = TTF_RenderText_Solid(font, data, rgba_to_sdl_color(&color));
    text->surface = TTF_RenderText_Blended(font, data, rgba_to_sdl_color(&color));
    text->texture = SDL_CreateTextureFromSurface(renderer, text->surface);
}
/// init a dynamic test
void init_text_dynamic(Text *text, SDL_Renderer *renderer, const char *data, TTF_Font *font, RGBA color, SDL_Surface *surface) {
    assert(text != NULL && "init_text: text was null");
    text->font = font;
    text->dynamic = true;
    text->buffer = (char*) malloc (sizeof(char) * (strlen(data) + 1));
    text->buffer = strcpy(text->buffer, data);
    text->color = color;
    text->renderer = renderer;
    // text->surface = TTF_RenderText_Solid(font, data, rgba_to_sdl_color(&color));
    // text->surface = TTF_RenderText_Blended(font, data, rgba_to_sdl_color(&color));
    text->surface = surface;
    text->texture = SDL_CreateTextureFromSurface(renderer, text->surface);
}

/// frees text itself
/// frees the memory allocated for text->data
/// frees the generated surface
/// frees the generated texture
void uninit_text(Text *text) {
    SDL_FreeSurface(text->surface);
    SDL_DestroyTexture(text->texture);
    free(text->buffer);
    free(text);
}

/// @slow this is an extremely slow operation
void set_text_color(Text *text, RGBA color) {
    assert(text != NULL && "init_text: text was null");
    text->color = color;
    SDL_FreeSurface(text->surface);
    SDL_DestroyTexture(text->texture);
    text->surface = TTF_RenderText_Solid(text->font, text->buffer, rgba_to_sdl_color(&color));
    ERROR_ON_NULL_SDL(text->surface);
    text->texture = SDL_CreateTextureFromSurface(text->renderer, text->surface);
    ERROR_ON_NULL_SDL(text->texture);
}

/// returns the rect of the texture based on font.
Rect get_text_rect(Text *text, int pos_x, int pos_y) {
    Rect result;
    TTF_SizeText(text->font, text->buffer, &result.w, &result.h);
    result.x = pos_x;
    result.y = pos_y;
    return result;
}

///
void render_text(SDL_Renderer *renderer, Text *text, int x, int y) {
    Rect text_rect = get_text_rect(text, x, y);
    if (SDL_RenderCopy(renderer, text->texture, NULL, &text_rect) != 0) {
        print_sdl_error();
    }
}

///
void render_text_rect(SDL_Renderer *renderer, Text *text, Rect rect) {
    Rect text_rect = get_text_rect(text, rect.x, rect.y);
    // // -- scale down text rect to fit the text inside of the given rect with proper aspect ratio
    if (text_rect.w > rect.w) {
        int diff = text_rect.w - rect.w;
        text_rect.w -= diff;
    }

    if (SDL_RenderCopy(renderer, text->texture, NULL, &text_rect) != 0) {
        print_sdl_error();
    }
}

/// generate all the glyph textures based on the font
void init_glyphs (SDL_Renderer *renderer, Glyphs *glyphs, TTF_Font* font, RGBA rgba) {
    for (int i = 0; i < GLYPHS_AMOUNT; ++i) {
        SDL_Surface *surface = TTF_RenderGlyph_Blended(font, (char)(GLYPHS_UNCODE_MIN + i), (SDL_Color) {rgba.r * 255, rgba.g * 255, rgba.b * 255, rgba.a * 255});
        glyphs->glyph[i] = surface;
        // glyphs->glyph[i] = SDL_CreateTextureFromSurface(renderer, surface);
        // SDL_FreeSurface(surface);
    }
    glyphs->font = font;
}

/// free all the textures generated by the glyphs
void uninit_glyphs (Glyphs *glyphs) {
    for (int i = 0; i < GLYPHS_AMOUNT; ++i) {
        // SDL_DestroyTexture(glyphs->glyph[i]);
        SDL_FreeSurface(glyphs->glyph[i]);
    }
    glyphs->font = NULL;
}

/// inits the given text based on the given glyphs
void glyphs_generate_text (Text *result, SDL_Renderer *renderer, Glyphs *glyphs, const char *string) {
    int width;
    int height;
    TTF_SizeText(glyphs->font, string, &width, &height);
    SDL_Surface *result_surface = SDL_CreateRGBSurface(0, width, height, 32, 0, 0, 0, 0); // @incomplete come back to this function and understand it better
    int offset_from_prev_glyph = 0;
    for (int i = 0; i < strlen(string); ++i) {
        int glyph_index = UNICODE_TO_GLYPH_INDEX((int)string[i]);
        
        // -- calculate where to put this glyph on the destination surface (result_surface)
        Rect dest_rect = {0};
        int minx, maxx, miny, maxy, advance;
        TTF_GlyphMetrics(glyphs->font, string[i], &minx, &maxx, &miny, &maxy, &advance);
        // advance -= 16;
        dest_rect.w = advance;
        dest_rect.h = maxy - miny;
        dest_rect.x = offset_from_prev_glyph;
        offset_from_prev_glyph += dest_rect.w; // advance offset
        dest_rect.y = 0;
        SDL_BlitSurface(glyphs->glyph[glyph_index], NULL, result_surface, &dest_rect);
    }
    // -- init the text
    init_text_dynamic(result, renderer, string, glyphs->font, glyphs->rgba, result_surface);
    // return result;
}