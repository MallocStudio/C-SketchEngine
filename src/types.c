#include "types.h"
#include "assert.h"
#include <memory.h>
#include "core.h"

///
SDL_Color rgba_to_sdl_color(const RGBA *rgba) {
    SDL_Color color;
    color.r = rgba->r * 255;
    color.g = rgba->g * 255;
    color.b = rgba->b * 255;
    color.a = rgba->a * 255;
    return color;
}

/// text should not be null
/// stores a pointer to the renderer and font for future use
/// allocates memory based on data
/// copies RGBA color to text->color
void init_text(Text *text, SDL_Renderer *renderer, const char *data, TTF_Font *font, RGBA color) {
    assert(text != NULL && "init_text: text was null");
    text->font = font;
    text->dynamic = false;
    text->buffer = (char*) malloc (sizeof(char) * (strlen(data) + 1));
    text->buffer = strcpy(text->buffer, data);
    text->color = color;
    text->renderer = renderer;
    text->surface = TTF_RenderText_Blended(font, data, rgba_to_sdl_color(&color));
    text->texture = SDL_CreateTextureFromSurface(renderer, text->surface);
}
/// init a dynamic text
void init_text_dynamic(Text *text, SDL_Renderer *renderer, const char *data, TTF_Font *font, RGBA color, SDL_Surface *surface) {
    assert(text != NULL && "init_text: text was null");
    text->font = font;
    text->dynamic = true;
    text->buffer = (char*) malloc (sizeof(char) * (strlen(data) + 1));
    text->buffer = strcpy(text->buffer, data);
    text->color = color;
    text->renderer = renderer;
    text->surface = surface;
    text->texture = SDL_CreateTextureFromSurface(renderer, text->surface);
    ERROR_ON_NULL_SDL(text->texture, "init_text_dynamic");
}

/// frees text itself
/// frees the memory allocated for text->data
/// frees the generated surface
/// frees the generated texture
void deinit_text(Text *text) {
    SDL_FreeSurface(text->surface);
    SDL_DestroyTexture(text->texture);
    free(text->buffer);
}

/// @slow this is an extremely slow operation
void set_text_color(Text *text, RGBA color) {
    assert(text != NULL && "init_text: text was null");
    text->color = color;
    SDL_FreeSurface(text->surface);
    SDL_DestroyTexture(text->texture);
    text->surface = TTF_RenderText_Solid(text->font, text->buffer, rgba_to_sdl_color(&color));
    ERROR_ON_NULL_SDL(text->surface, "set_text_color");
    text->texture = SDL_CreateTextureFromSurface(text->renderer, text->surface);
    ERROR_ON_NULL_SDL(text->texture, "set_text_color");
}

/// returns the rect of the texture based on font.
Rect get_text_rect(Text *text, int pos_x, int pos_y) {
    Rect result;
    TTF_SizeText(text->font, text->buffer, &result.w, &result.h);
    result.x = pos_x;
    result.y = pos_y;
    return result;
}

/// generate all the glyph textures based on the font
void init_glyphs (SDL_Renderer *renderer, Glyphs *glyphs, TTF_Font* font, RGBA rgba) {
    for (int i = 0; i < GLYPHS_AMOUNT; ++i) {
        SDL_Surface *surface = TTF_RenderGlyph_Blended(font, (char)(GLYPHS_UNCODE_MIN + i), (SDL_Color) {rgba.r * 255, rgba.g * 255, rgba.b * 255, rgba.a * 255});
        glyphs->glyph[i] = surface;
        // glyphs->glyph[i] = SDL_CreateTextureFromSurface(renderer, surface);
        // SDL_FreeSurface(surface);
    }
    glyphs->font = font;
}

/// free all the textures generated by the glyphs
void deinit_glyphs (Glyphs *glyphs) {
    for (int i = 0; i < GLYPHS_AMOUNT; ++i) {
        // SDL_DestroyTexture(glyphs->glyph[i]);
        SDL_FreeSurface(glyphs->glyph[i]);
    }
    glyphs->font = NULL;
}

/// inits the given text based on the given glyphs
void generate_text_from_glyphs (Text *result, SDL_Renderer *renderer, Glyphs *glyphs, const char *string) {
    int string_width;
    int string_height;
    TTF_SizeText(glyphs->font, string, &string_width, &string_height);

    // SDL interprets each pixel as a 32-bit number, so our masks must depend on the endianness (byte order) of the machine
    Uint32 rmask, gmask, bmask, amask;
    #if SDL_BYTEORDER == SDL_BIG_ENDIAN
        rmask = 0xff000000;
        gmask = 0x00ff0000;
        bmask = 0x0000ff00;
        amask = 0x000000ff;
    #else
        rmask = 0x000000ff;
        gmask = 0x0000ff00;
        bmask = 0x00ff0000;
        amask = 0xff000000;
    #endif
    
    SDL_Surface *result_surface = SDL_CreateRGBSurface(0, string_width, string_height, 32, rmask, gmask, bmask, amask);
    
    int offset_from_prev_glyph = 0;
    for (int i = 0; i < strlen(string); ++i) {
        // -- calculate where to put this glyph on the destination surface (result_surface)
        Rect dest_rect = {0};
        int minx, maxx, miny, maxy, advance;
        TTF_GlyphMetrics(glyphs->font, string[i], &minx, &maxx, &miny, &maxy, &advance);

        dest_rect.x = offset_from_prev_glyph;
        dest_rect.y = 0;
        dest_rect.w = advance;
        dest_rect.h = maxy - miny;
        
        offset_from_prev_glyph += dest_rect.w; // advance offset

        int glyph_index = UNICODE_TO_GLYPH_INDEX((int)string[i]);
        SDL_BlitSurface(glyphs->glyph[glyph_index], NULL, result_surface, &dest_rect);
    }
    // -- init the text
    init_text_dynamic(result, renderer, string, glyphs->font, glyphs->rgba, result_surface);
}

// /// simply render the given string using the given font at the given pos
// void render_string(SDL_Renderer *renderer, TTF_Font *font, const char *string, Vec2i pos) {
//     Text text;
//     generate_text_from_glyphs(&text, renderer, 
// }

///
void init_renderer (Renderer *renderer) {
    renderer->glyphs = new(Glyphs);

    // -- @temp
    TTF_Font *font = TTF_OpenFont(DEFAULT_FONT_PATH, 16);
    if (font == NULL) {
        printf("Error: could not load font at %s\n", DEFAULT_FONT_PATH);
        print_ttf_error();
    }

    // -- glyphs test
    init_glyphs(renderer->sdl_renderer, renderer->glyphs, font, (RGBA){1, 1, 1, 1});
}

void deinit_renderer (Renderer *renderer) {
    deinit_glyphs(renderer->glyphs);
    free(renderer->glyphs);
}